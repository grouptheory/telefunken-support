{
    "collab_server" : "",
    "contents" : "# make config geaph\nmakeGraph <- function(d){\n  n <- length(d)\n  edges <- list()\n  d1 <- d\n  while(sum(d1)>0.5){\n    l <- sample.int(n,1,prob=d1)\n    dt <- d1\n    dt[l] <- d1[l] - 1\n    if(sum(dt) > 0.5){\n      k <- sample.int(n,1,prob=dt)\n      v <- TRUE\n      d1[k] <- d1[k] - 1\n    }else{\n      k <- sample.int(n,1,prob=d)\n      v <- FALSE\n    }\n    d1[l] <- d1[l] - 1\n    edges[[length(edges)+1]] <- c(l,k,v)\n  }\n  el <- do.call(rbind,edges)\n  el\n}\n\n#rds sampler\nsampRDS <- function(el, d, ns, g, ss, biased=TRUE,pr = c(0,.1,.9)){\n  maxR <- length(pr) -1\n  n <- length(g)\n  ml <- if(is.factor(g)) max(levels(g)) else max(g)\n  if(biased){\n    seeds <- sample.int(n,ns,prob=as.numeric(as.factor(g))-1)\n  }else{\n    seeds <- sample.int(n,ns, prob = d)\n  }\n  samp <- seeds\n  recr <- rep(-1,ns)\n  time <- 0 + (1:ns)/10000000\n  rcTime <- rexp(ns)\n  v <- rep(-1,ns)\n  t1 <- time\n  while(length(samp) < ss){\n    subjIndex <- which.min(t1 + rcTime)\n    if(length(subjIndex)==0){\n      print(\"redraw\")\n      subj <- sample( (1:n)[-samp],1)\n      samp <- c(samp,subj)\n      recr <- c(recr,-1)\n      time <- c(time,max(time+1))\n      rcTime <- c(rcTime,rexp(1))\n      t1 <- c(t1,max(time+1))\n      v <- c(v,-1)\n    }else{\n      t <- t1[subjIndex] + rcTime[subjIndex]\n      t1[subjIndex] <- NA\n      subj <- samp[subjIndex]\n      nr <- sample(0:maxR,1,replace=FALSE,prob=pr)\n      nbrs <- rbind(el[el[,1]==subj,2:3,drop=FALSE],\n                    el[el[,2]==subj & el[,3]>0.5,c(1,3),drop=FALSE]\n      )\n      nbrs <- nbrs[!(nbrs[,1] %in% samp) & nbrs[,1]!=subj,,drop=FALSE]\n      nr <- min(nr,nrow(nbrs))\n      if(nr>0){\n        s <- sample.int(nrow(nbrs),nr,replace=FALSE)\n        s <- s[!duplicated(nbrs[s,1])]\n        nr <- length(s)\n        samp <- c(samp,nbrs[s,1])\n        recr <- c(recr,rep(subj,nr))\n        tm <- t + t + (0:(nr-1)) / 1000000\n        time <- c(time,tm)\n        t1 <- c(t1,tm)\n        rcTime <- c(rcTime,rexp(nr))\n        v <- c(v,nbrs[s,2])\n      }\n    }\n  }\n  data.frame(subject=samp,recruiter=recr,time=time,v=v)\n}\n\n#get the root seed for each subject\ngetSeed <- function(id, recruiter.id){\n  sid <- -1\n  get.seed <- function(i, history) {\n    row <- match(i, id)\n    rec.id <- recruiter.id[row]\n    if(rec.id==i){\n      stop(sprintf(\"Yikes! The data says that the person with id %s recruited themselves! Please check that the coupon information in the data for that person is correct :-)\",i),call.=FALSE)}\n    if(rec.id %in% history){\n      stop(\"Loop found in recruitment tree.\")\n    }\n    if (rec.id == sid) {\n      return(i)\n    }\n    else {\n      get.seed(rec.id,history=c(history,i))\n    }\n  }\n  seed <- sapply(id, get.seed,history=c())\n  seed\n}\n\n\n\npopulationEstimate <- function(subject, recruiter, degree, nbrs){\n  ns <- length(subject)\n  outSet <- do.call(c, apply(cbind(subject,recruiter), 1, function(x){\n    excl <- c(x[2], subject[recruiter == x[1]])\n    nb <- nbrs[[x[1]]]\n    for(e in excl){\n      i <- which(nb %in% e)\n      if(length(i) > 0)\n        nb <- nb[-i[1]]\n    }\n    nb\n  }))\n  m <- length(outSet[outSet %in% subject])\n  dSample <- mean(degree) - 1\n  dPopulation <- ns / sum(1/degree)\n  #browser()\n  result <- list(\n    estimate=(dSample / dPopulation) * ns * length(outSet) / m ,\n    noDegreeEstimate=ns * length(outSet) / m\n  )\n  seed <- getSeed(subject,recruiter)\n  seedIds <- unique(seed)\n  crossSeedEstimateNum <- 0\n  crossSeedEstimateDenom <- 0\n  for(s in seedIds){\n    outSet <- do.call(c, as.list(apply(cbind(subject[seed == s],recruiter[seed == s]), 1, function(x){\n      excl <- c(x[2], subject[recruiter == x[1]])\n      nb <- nbrs[[x[1]]]\n      for(e in excl){\n        i <- which(nb %in% e)\n        if(length(i) > 0)\n          nb <- nb[-i[1]]\n      }\n      nb\n    })))\n    if(is.null(outSet))\n      next\n    m <- length(outSet[outSet %in% subject[seed != s]])\n    dSample <- mean(degree[seed != s]) - 1\n    dPopulation <- ns / sum(1/degree)\n    crossSeedEstimateNum <- crossSeedEstimateNum + length(outSet) * \n      length(subject[seed != s]) * dSample / dPopulation\n    crossSeedEstimateDenom <- crossSeedEstimateDenom + m\n  }\n  #print(crossSeedEstimateNum)\n  #print(crossSeedEstimateDenom)\n  result$crossSeedEstimate <- crossSeedEstimateNum / crossSeedEstimateDenom\n  result\n}\n\n\n\npopulationEstimateHash <- function(subject, recruiter, degree, nbrs, hash, rho){\n  ns <- length(subject)\n  outSet <- apply(cbind(subject,recruiter), 1, function(x){\n    excl <- c(hash[x[2]], hash[subject[recruiter == x[1]]])\n    nb <- hash[nbrs[[x[1]]]]\n    for(e in excl){\n      i <- which(nb %in% e)\n      if(length(i) > 0)\n        nb <- nb[-i[1]]\n    }\n    nb\n  })\n  #browser()\n  dSample <- mean(degree) - 1\n  dPopulation <- ns / sum(1/degree)\n  matchSet <- lapply(outSet, function(x) x[x %in% hash[subject]])\n\n  NTilda <- function(N){\n    wts <-  lapply(matchSet, function(x){\n      wts1 <- list()\n      for(a in x){\n        mId <- which(hash[subject] == a)\n        for(id in mId){\n          wts1[[length(wts1) + 1]] <- 1 / (dPopulation * rho * (N - 1) / (degree[id] - 1) + 1)\n        }\n      }\n      unlist(wts1)\n    })\n    m <- sum(unlist(wts))\n    (dSample / dPopulation) * ns * length(unlist(outSet)) / m\n  }\n  opt <- uniroot(function(N) NTilda(N) - N, interval=c(2, 7000000000))\n  \n  seed <- getSeed(subject,recruiter)\n  seedIds <- unique(seed)  \n  NTildaCross <- function(N){\n    crossSeedEstimateNum <- 0\n    crossSeedEstimateDenom <- 0\n    for(s in seedIds){\n      outSet <- apply(cbind(subject[seed == s],recruiter[seed == s]), 1, function(x){\n        excl <- c(hash[x[2]], hash[subject[recruiter == x[1]]])\n        nb <- hash[nbrs[[x[1]]]]\n        for(e in excl){\n          i <- which(nb %in% e)\n          if(length(i) > 0)\n            nb <- nb[-i[1]]\n        }\n        nb\n      })\n      if(is.null(outSet))\n        next\n      matchSet <- lapply(outSet, function(x) x[x %in% hash[subject[seed != s]]])\n      wts <-  lapply(matchSet, function(x){\n        wts1 <- list()\n        for(a in x){\n          mId <- which(hash[subject] == a & seed != s)\n          for(id in mId){\n            wts1[[length(wts1) + 1]] <- 1 / (dPopulation * rho * (N - 1) / (degree[id] - 1) + 1)\n          }\n        }\n        unlist(wts1)\n      })\n      m <- sum(unlist(wts))\n      dSample <- mean(degree[seed != s]) - 1\n      dPopulation <- ns / sum(1/degree)\n      crossSeedEstimateNum <- crossSeedEstimateNum + length(unlist(outSet)) * \n        length(subject[seed != s]) * dSample / dPopulation\n      crossSeedEstimateDenom <- crossSeedEstimateDenom + m\n      #print(length(unlist(outSet)) * \n      #        length(subject[seed != s]) * dSample / dPopulation / m)\n    }\n    crossSeedEstimateNum / crossSeedEstimateDenom\n  }\n  optCross <- uniroot(function(N) NTildaCross(N) - N, interval=c(2, 7000000000))\n  result <- list(\n    estimate=opt$root,\n    crossSeedEstimate= optCross$root\n  )\n  result\n}\n",
    "created" : 1488938384261.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "426601674",
    "id" : "1CA10A22",
    "lastKnownWriteTime" : 1487921453,
    "last_content_update" : 1487921453,
    "path" : "~/Dropbox/telefunken2_BK/R/rds-pop.R",
    "project_path" : "rds-pop.R",
    "properties" : {
        "tempName" : "Untitled1"
    },
    "relative_order" : 2,
    "source_on_save" : false,
    "source_window" : "",
    "type" : "r_source"
}